local nmath = require "math"

local math: type = @record{}

-----------------------------------------------
-------------------- Utils --------------------
-----------------------------------------------
function math.lerp(start: number, stop: number, x: number): number
  return start + x * (stop - start)
end

function math.norm(start: number, stop: number, x: number): number
  return (x - start) / (stop - start)
end

function math.map(start_1: number, stop_1: number, start_2: number, stop_2: number, x: number): number
  return (x - start_1) / (stop_1 - start_1) * (stop_2 - start_2) + start_2
end

----------------------------------------------
-------------------- Vec2 --------------------
----------------------------------------------
local math.Vec2: type = @record{
  x: number,
  y: number,
}

function math.Vec2.__eq(a: math.Vec2, b: math.Vec2): boolean
  return (a.x == b.x) and (a.y == b.y)
end

function math.Vec2.__add(a: math.Vec2, b: math.Vec2): math.Vec2
  return {
    x = a.x + b.x,
    y = a.y + b.y,
  }
end

function math.Vec2.__sub(a: math.Vec2, b: math.Vec2): math.Vec2
  return {
    x = a.x - b.x,
    y = a.y - b.y,
  }
end

function math.Vec2.__unm(a: math.Vec2): math.Vec2
  return {
    x = -a.x,
    y = -a.y,
  }
end

function math.Vec2:__len(): number
  return nmath.sqrt((self.x * self.x) + (self.y * self.y))
end

function math.Vec2:__tostring(): string
  return "Vec2(" .. self.x .. ", " .. self.y .. ")"
end

----------------------------------------------
-------------------- Vec3 --------------------
----------------------------------------------
local math.Vec3: type = @record{
  x: number,
  y: number,
  z: number,
}

function math.Vec3.__eq(a: math.Vec3, b: math.Vec3): boolean
  return (a.x == b.x) and (a.y == b.y) and (a.z == b.z)
end

function math.Vec3.__add(a: math.Vec3, b: math.Vec3): math.Vec3
  return {
    x = a.x + b.x,
    y = a.y + b.y,
    z = a.z + b.z,
  }
end

function math.Vec3.__sub(a: math.Vec3, b: math.Vec3): math.Vec3
  return {
    x = a.x - b.x,
    y = a.y - b.y,
    z = a.z - b.z,
  }
end

function math.Vec3.__unm(a: math.Vec3): math.Vec3
  return {
    x = -a.x,
    y = -a.y,
    z = -a.z,
  }
end

function math.Vec3:__len(): number
  return nmath.sqrt((self.x * self.x) + (self.y * self.y) + (self.z * self.z))
end

function math.Vec3:__tostring(): string
  return "Vec3(" .. self.x .. ", " .. self.y .. ", " .. self.z .. ")"
end

----------------------------------------------------
-------------------- Quaternion --------------------
----------------------------------------------------
local math.Quaternion: type = @record{
  x: number,
  y: number,
  z: number,
  w: number,
}

function math.Quaternion.__eq(a: math.Quaternion, b: math.Quaternion): boolean
  return (a.x == b.x) and (a.y == b.y) and (a.z == b.z) and (a.w == b.w)
end

function math.Quaternion.__add(a: math.Quaternion, b: math.Quaternion): math.Quaternion
  return {
    x = a.x + b.x,
    y = a.y + b.y,
    z = a.z + b.z,
    w = a.w + b.w,
  }
end

function math.Quaternion.__sub(a: math.Quaternion, b: math.Quaternion): math.Quaternion
  return {
    x = a.x - b.x,
    y = a.y - b.y,
    z = a.z - b.z,
    w = a.w - b.w,
  }
end

function math.Quaternion.__unm(a: math.Quaternion): math.Quaternion
  return {
    x = -a.x,
    y = -a.y,
    z = -a.z,
    w = -a.w,
  }
end

function math.Quaternion:__len(): number
  return nmath.sqrt((self.x * self.x) + (self.y * self.y) + (self.z * self.z) + (self.w * self.w))
end

function math.Quaternion:__tostring(): string
  return "Quaternion(" .. self.x .. ", " .. self.y .. ", " .. self.z .. ", " .. self.w .. ")"
end

return math
