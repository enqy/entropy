require "wgpu"

local World = require "entropy.world"
local Renderer = require "entropy.render.renderer"
local Shader = require "entropy.render.shader"
local Mat4 = require "entropy.math.mat4"
local Vec4 = require "entropy.math.vec4"
local Mesh = require "entropy.scene.mesh"

require "memory"

local Globals = @record{
  mvp: Mat4,
}

local Impl: type = @record{
  globals_buffer: WGPUBuffer,
  globals_bind_group: WGPUBindGroup,

  pipeline: WGPURenderPipeline,
}
## Impl.value.is_renderer_impl = true

function Impl:init(renderer: a_renderer): void
  -- load vertex shader
  local vs_shader = Shader.load_from_file("entropy/render/impl/basic/vert.wgsl")
  vs_shader:create(renderer.device)

  -- vertex shader stuff
  local vertex_buffer_layouts: []WGPUVertexBufferLayout = {
    {
      arrayStride = #Mesh.Vertex,
      stepMode = WGPUVertexStepMode_Vertex,
      attributeCount = 3,
      attributes = &(@[]WGPUVertexAttribute){
        {
          shaderLocation = 0,
          offset = 0,
          format = WGPUVertexFormat_Float32x3,
        },
        {
          shaderLocation = 1,
          offset = 12,
          format = WGPUVertexFormat_Float32x4,
        },
        {
          shaderLocation = 2,
          offset = 28,
          format = WGPUVertexFormat_Float32x2,
        },
      },
    },
  }
  local vertex = (@WGPUVertexState){
    module = vs_shader.module,
    entryPoint = "main",
    bufferCount = #vertex_buffer_layouts,
    buffers = &vertex_buffer_layouts,
  }

  local fs_shader = Shader.load_from_file("entropy/render/impl/basic/frag.wgsl")
  fs_shader:create(renderer.device)

  -- fragment shader stuff
  local blend = (@WGPUBlendState){
    color = (@WGPUBlendComponent){
      srcFactor = WGPUBlendFactor_One,
      dstFactor = WGPUBlendFactor_OneMinusSrcAlpha,
      operation = WGPUBlendOperation_Add,
    },
    alpha = (@WGPUBlendComponent){
      srcFactor = WGPUBlendFactor_One,
      dstFactor = WGPUBlendFactor_OneMinusSrcAlpha,
      operation = WGPUBlendOperation_Add,
    },
  }
  local color_target = (@WGPUColorTargetState){
    format = renderer.target_config.format,
    blend = &blend,
    writeMask = WGPUColorWriteMask_All,
  }
  local fragment = (@WGPUFragmentState){
    module = fs_shader.module,
    entryPoint = "main",
    targetCount = 1,
    targets = &color_target,
  }

  -- globals bind group
  local globals_bind_group_layout_entries: []WGPUBindGroupLayoutEntry = {
    (@WGPUBindGroupLayoutEntry){
      binding = 0,
      visibility = WGPUShaderStage_Vertex,
      buffer = (@WGPUBufferBindingLayout){
        type = WGPUBufferBindingType_Uniform,
        hasDynamicOffset = false,
        minBindingSize = #Globals,
      },
    },
  }
  local globals_bind_group_layout = wgpuDeviceCreateBindGroupLayout(
    renderer.device,
    (@WGPUBindGroupLayoutDescriptor){
      entryCount = #globals_bind_group_layout_entries,
      entries = &globals_bind_group_layout_entries,
    }
  )
  self.globals_buffer = wgpuDeviceCreateBuffer(
    renderer.device,
    &(@WGPUBufferDescriptor){
      label = "basic globals buffer",
      usage = WGPUBufferUsage_Uniform | WGPUBufferUsage_CopyDst,
      size = #Globals,
      mappedAtCreation = false,
    }
  )
  self.globals_bind_group = wgpuDeviceCreateBindGroup(
    renderer.device,
    &(@WGPUBindGroupDescriptor){
      label = "basic globals bind group",
      layout = globals_bind_group_layout,
      entryCount = 1,
      entries = &(@[]WGPUBindGroupEntry){
        (@WGPUBindGroupEntry){
          binding = 0,
          buffer = self.globals_buffer,
          size = #Globals,
        },
      },
    }
  )

  -- setup pipelines
  local pipeline_layout = wgpuDeviceCreatePipelineLayout(
    renderer.device,
    &(@WGPUPipelineLayoutDescriptor){
      bindGroupLayoutCount = 1,
      bindGroupLayouts = &(@[]WGPUBindGroupLayout){
        globals_bind_group_layout
      },
      nextInChain = (@*WGPUChainedStruct)(&(@WGPUPipelineLayoutExtras){
        chain = (@WGPUChainedStruct){
          sType = WGPUSType_PipelineLayoutExtras,
        },
        pushConstantRangeCount = 1,
        pushConstantRanges = &(@[]WGPUPushConstantRange){
          {
            stages = WGPUShaderStage_Vertex,
            start = 0,
            End = #Mat4,
          },
        },
      }),
    }
  )
  local pipeline_descriptor = (@WGPURenderPipelineDescriptor){
    label = "basic render pipeline",
    layout = pipeline_layout,
    vertex = vertex,
    fragment = &fragment,
    primitive = (@WGPUPrimitiveState){
      cullMode = WGPUCullMode_Back,
      topology = WGPUPrimitiveTopology_TriangleList,
      stripIndexFormat = WGPUIndexFormat_Undefined,
      frontFace = WGPUFrontFace_CCW,
    },
    multisample = (@WGPUMultisampleState){
      count = 1,
      mask = 0xffffffff,
      alphaToCoverageEnabled = false,
    },
    depthStencil = &(@WGPUDepthStencilState){
      format = WGPUTextureFormat_Depth24PlusStencil8,
      depthWriteEnabled = true,
      depthCompare = WGPUCompareFunction_Less,
      stencilFront = (@WGPUStencilFaceState){
        compare = WGPUCompareFunction_Always,
        failOp = WGPUStencilOperation_Keep,
        depthFailOp = WGPUStencilOperation_Keep,
        passOp = WGPUStencilOperation_Keep,
      },
      stencilBack = (@WGPUStencilFaceState){
        compare = WGPUCompareFunction_Always,
        failOp = WGPUStencilOperation_Keep,
        depthFailOp = WGPUStencilOperation_Keep,
        passOp = WGPUStencilOperation_Keep,
      },
      stencilReadMask = 0xffffffff,
      stencilWriteMask = 0xffffffff,
    },
  }
  self.pipeline = wgpuDeviceCreateRenderPipeline(renderer.device, &pipeline_descriptor)

  -- cleanup now unneeded resources
  vs_shader:cleanup()
  fs_shader:cleanup()
  wgpuPipelineLayoutDrop(pipeline_layout)
  wgpuBindGroupLayoutDrop(globals_bind_group_layout)
end

function Impl:cleanup(renderer: a_renderer): void
  wgpuRenderPipelineDrop(self.pipeline)
  wgpuBufferDrop(self.globals_buffer)
  wgpuBindGroupDrop(self.globals_bind_group)
end

function Impl:resize(renderer: a_renderer): void
end

function Impl:prepare(renderer: a_renderer, world: *World): void
end

function Impl:render(renderer: a_renderer, pass: WGPURenderPassEncoder, encoder: WGPUCommandEncoder, target: WGPUTextureView, world: *World): void
  -- get primary camera
  local camera = world:s("entropy.scene.cameras")[0]
  local view = camera:view_matrix()
  local proj = camera:proj_matrix(renderer.target_config.width, renderer.target_config.height)

  wgpuQueueWriteBuffer(
    renderer.queue,
    self.globals_buffer,
    0,
    &(@Globals){
      mvp = (proj * view):transpose(),
    },
    #Globals
  )

  wgpuRenderPassEncoderSetPipeline(pass, self.pipeline)
  wgpuRenderPassEncoderSetBindGroup(pass, 0, self.globals_bind_group, 0, nilptr)

  local meshes = world:s("entropy.scene.meshes")
  for id, mesh in mpairs(meshes) do
    wgpuRenderPassEncoderSetVertexBuffer(pass, 0, mesh.vertex_buffer, 0, 0)
    wgpuRenderPassEncoderSetIndexBuffer(pass, mesh.index_buffer, WGPUIndexFormat_Uint32, 0)
    local model = mesh.transform:transpose()
    wgpuRenderPassEncoderSetPushConstants(pass, WGPUShaderStage_Vertex, 0, #Mat4, &model)
    wgpuRenderPassEncoderDrawIndexed(pass, #mesh.indices, 1, 0, 0, 0)
  end
end

return Impl
